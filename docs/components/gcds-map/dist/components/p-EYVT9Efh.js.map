{"file":"p-EYVT9Efh.js","mappings":"AAAO,SAAS,YAAY,CAAC,cAAc,EAAE;AAC7C,EAAE,IAAI,CAAC,GAAG,cAAc,CAAC,IAAI,IAAI,cAAc,CAAC,YAAY;AAC5D,EAAE,IAAI,CAAC,KAAK,SAAS,EAAE;;AAEvB,EAAE,MAAM,uBAAuB,GAAG,CAAC,WAAW,KAAK;AACnD;AACA,IAAI,MAAM,qBAAqB,GAAG,KAAK,CAAC,IAAI;AAC5C,MAAM,IAAI,CAAC,UAAU,CAAC,gBAAgB,CAAC,iDAAiD;AACxF,KAAK;;AAEL;AACA,IAAI,IAAI,qBAAqB,CAAC,MAAM,KAAK,CAAC,EAAE;AAC5C,MAAM,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS;AACjD,MAAM,IAAI,CAAC,SAAS,EAAE;AACtB,QAAQ,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE;AAChE;AACA;AACA,MAAM,MAAM,KAAK,GAAG,SAAS,CAAC,QAAQ,KAAK,KAAK;AAChD,MAAM,MAAM,WAAW,GAAG,SAAS,CAAC,SAAS,EAAE,QAAQ,CAAC,wBAAwB,CAAC;AACjF,0BAA0B,SAAS,CAAC,SAAS,EAAE,QAAQ,CAAC,6BAA6B,CAAC;AACtF;AACA,MAAM,OAAO,CAAC,KAAK,IAAI,WAAW;AAClC,UAAU,EAAE,QAAQ,EAAE,aAAa,EAAE,IAAI,EAAE,SAAS;AACpD,UAAU,EAAE,QAAQ,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE;AACnD;;AAEA;AACA,IAAI,MAAM,6BAA6B;AACvC,MAAM,WAAW,CAAC,QAAQ,IAAI,WAAW,CAAC,OAAO;;AAEjD;AACA,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,qBAAqB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC3D,MAAM,MAAM,QAAQ,GAAG,qBAAqB,CAAC,CAAC,CAAC;AAC/C,MAAM,MAAM,oCAAoC;AAChD,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,OAAO;;AAE7C;AACA,MAAM;AACN,QAAQ,oCAAoC;AAC5C,QAAQ,6BAA6B,CAAC,uBAAuB;AAC7D,UAAU;AACV,SAAS,GAAG,IAAI,CAAC;AACjB,QAAQ;AACR;AACA,QAAQ,OAAO,EAAE,QAAQ,EAAE,aAAa,EAAE,IAAI,EAAE,QAAQ,EAAE;AAC1D;AACA;;AAEA;AACA,IAAI,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,IAAI,EAAE,qBAAqB,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;AACvE,GAAG;;AAEH,EAAE,IAAI,eAAe,GAAG,uBAAuB,CAAC,CAAC,CAAC;AAClD,EAAE,eAAe,CAAC,IAAI,CAAC,qBAAqB,CAAC,eAAe,CAAC,QAAQ,EAAE,CAAC,CAAC;AACzE;;;;","names":[],"sources":["src/components/utils/mapml/elementSupport/layers/renderStyles.js"],"sourcesContent":["export function renderStyles(mapStyleOrLink) {\n  let e = mapStyleOrLink.link || mapStyleOrLink.styleElement;\n  if (e === undefined) return;\n\n  const getStylePositionAndNode = (styleOrLink) => {\n    // Get all already rendered <style> or <link> elements in the shadow DOM container\n    const renderedSiblingStyles = Array.from(\n      this._container.querySelectorAll(':scope > style, :scope > link[rel=\"stylesheet\"]')\n    );\n\n    // If there are no rendered styles or links yet, insert before any content\n    if (renderedSiblingStyles.length === 0) {\n      const lastChild = this._container.lastChild;\n      if (!lastChild) {\n        return { position: 'afterbegin', node: this._container };\n      }\n      \n      const isSVG = lastChild.nodeName === 'SVG';\n      const isContainer = lastChild.classList?.contains('mapml-vector-container') ||\n                          lastChild.classList?.contains('mapml-extentlayer-container');\n      \n      return (isSVG || isContainer)\n        ? { position: 'beforebegin', node: lastChild }\n        : { position: 'afterend', node: lastChild };\n    }\n\n    // Peek into the light DOM context for comparison\n    const mapStyleOrLinkLightDOMElement =\n      styleOrLink.mapStyle || styleOrLink.mapLink;\n\n    // Traverse the rendered siblings in the shadow DOM\n    for (let i = 0; i < renderedSiblingStyles.length; i++) {\n      const rendered = renderedSiblingStyles[i];\n      const siblingMapStyleOrLinkLightDOMElement =\n        rendered.mapStyle || rendered.mapLink;\n\n      // Compare the light DOM order\n      if (\n        siblingMapStyleOrLinkLightDOMElement &&\n        mapStyleOrLinkLightDOMElement.compareDocumentPosition(\n          siblingMapStyleOrLinkLightDOMElement\n        ) & Node.DOCUMENT_POSITION_FOLLOWING\n      ) {\n        // Insert the new style or link before the already-rendered sibling element\n        return { position: 'beforebegin', node: rendered };\n      }\n    }\n\n    // If no preceding sibling was found, insert after the last rendered element\n    return { position: 'afterend', node: renderedSiblingStyles.at(-1) };\n  };\n\n  let positionAndNode = getStylePositionAndNode(e);\n  positionAndNode.node.insertAdjacentElement(positionAndNode.position, e);\n}\n"],"version":3}